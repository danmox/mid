#!/usr/bin/env python3

import argparse
import re
from pathlib import Path


def merge_main(args):

    if len(args.logs) < 2:
        print('must provide 2 or more logfiles to merge')
        return

    log_filenames = [Path(f) for f in args.logs]
    for name in log_filenames:
        if not name.exists():
            print(f'logfile {name} does not exist')
            return

    print(f"merging: {', '.join(args.logs)}")

    entries = []
    for filename in log_filenames:
        # open file and extract the timestamp from each line
        with open(filename, 'r') as f:
            for line in f:
                ts = float(re.match('^\[([0-9.]+)\].*$', line).group(1))
                entries.append((ts, line))

    # sort by timestamp
    entries.sort(key=lambda x: x[0])

    # write to output file
    outlogfilename = args.output
    with open(outlogfilename, 'w') as f:
        for ts, line in entries:
            f.write(line)

    print(f'wrote contents to: {outlogfilename}')



action_set = set(['RECEIVE', 'SEND', 'RELAY', 'RETRY', 'CANCEL_RETRY', 'DROP_SUP',
                  'DROP_DUP', 'DROP_ECHO', 'DROP_LOWPRI', 'QUEUE', 'ACK', 'DELIVER'])
msg_type_set = set(['STATUS', 'PAYLOAD', 'PING_REQ', 'PING_RES', 'ACK', 'ROUTING_TABLE'])


def print_main(args):

    log_filename = Path(args.log)
    if not log_filename.exists():
        print(f'logfile {log_filename} does not exist')
        return

    if args.action is not None and args.action not in action_set:
        print(f'invalid action {args.action}')
        return
    action = args.action
    if args.type is not None and args.type not in msg_type_set:
        print(f'invalid msg_type {args.type}')
        return
    msg_type = args.type

    line_matcher = re.compile('^\[([0-9.]+)\] ([0-9]+): ([A-Z_]+) ([A-Z_]+): ([0-9]+) > ([0-9]+) v ([0-9]+) bytes=([0-9]+) relays=\[([0-9, ]+)\] seq=([0-9]+) att=([0-9]+) rel=([A-Z]+)(.*)$')
    def parse_line(line, regex=line_matcher):
        m = regex.match(line)
        if m is None:
            return None
        return {'timestamp': float(m.group(1)),
                'node_id': int(m.group(2)),
                'action': m.group(3),
                'msg_type': m.group(4),
                'src_id': int(m.group(5)),
                'dest_id': int(m.group(6)),
                'curr_id': int(m.group(7)),
                'bytes': int(m.group(8)),
                'relays': [int(x) for x in m.group(9).split(',')],
                'seq': int(m.group(10)),
                'attempt': int(m.group(11)),
                'reliable': m.group(12),
                'extra': m.group(13)}

    with open(log_filename, 'r') as f:
        first_line = f.readline()
        log_start = float(re.match('^\[([0-9.]+)\].*$', first_line).group(1))
        for line in f:
            pass
        last_line = line
        log_end = float(re.match('^\[([0-9.]+)\].*$', last_line).group(1))

    start_time = log_start
    end_time = log_end
    log_duration = log_end - log_start
    if args.start is not None:
        if args.start > log_duration:
            print(f'given start time ({args.start:.2f}s) after log end ({log_duration:.2f}s)')
            return
        start_time = args.start + log_start
    if args.end is not None:
        if args.end > log_duration:
            print(f'given end time ({args.end:.2f}s) after log end ({log_duration:.2f}s)')
            return
        end_time = args.end + log_start

    time_str_len = len(f'{log_end - log_start:.0f}') + 7
    print_count = 0
    f = open(log_filename, 'r')
    for line in f:

        d = parse_line(line)
        t = d['timestamp']

        if t < start_time:
            continue
        if t > end_time:
            break

        if args.node is not None and d['node_id'] != args.node:
            continue
        if args.seq is not None and d['seq'] != args.seq:
            continue
        if action is not None and d['action'] != action:
            continue
        if msg_type is not None and d['msg_type'] != msg_type:
            continue
        if args.count is not None and print_count + 1 > args.count:
            break
        if args.src is not None and d['src_id'] != args.src:
            continue
        if args.dest is not None and d['dest_id'] != args.dest:
            continue


        print_count += 1
        if args.quiet:
            continue

        time_str = f'{t - log_start:.6f}'
        time_str = (time_str_len - len(time_str))*' ' + time_str

        print(f"[{time_str}] {d['node_id']}: {d['action']} {d['msg_type']}:"
              f" {d['src_id']} > {d['dest_id']} v {d['curr_id']} bytes={d['bytes']}"
              f" seq={d['seq']} try={d['attempt']} rel={d['reliable']} "
              f"relays={d['relays']}{d['extra']}")

    print(f'{print_count} messages')


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='operations on rosbag logs generated by or_protocol')
    subparsers = parser.add_subparsers(dest='command', required=True)

    # bag merging
    merge_parser = subparsers.add_parser('merge', help='merge multiple rosbags')
    merge_parser.add_argument('logs', type=str, nargs='+', help='logfiles to merge')
    merge_parser.add_argument('-o', '--output', type=str, default='merged.txt', help='name of output logfile')

    # print bag contents
    print_parser = subparsers.add_parser('print', help='print contents of log in a human readable fashion')
    print_parser.add_argument('log', type=str, help='logfile to print')
    print_parser.add_argument('-t', '--type', type=str, help='only print messages of a particular type',
                              choices=list(msg_type_set))
    print_parser.add_argument('-a', '--action', type=str, help='only print messages of a particular action',
                              choices=list(action_set))
    print_parser.add_argument('-c', '--count', type=int, help='number of messages to print')
    print_parser.add_argument('-q', '--quiet', action='store_true', help='only print the message count')
    print_parser.add_argument('-s', '--seq', type=int, help='print messages related to a given seq number')
    print_parser.add_argument('-n', '--node', type=int, help='print messages processed at the given ID')
    print_parser.add_argument('--src', type=int, help='print messages originating at the given src node')
    print_parser.add_argument('--dest', type=int, help='print messages intended for the given dest node')
    print_parser.add_argument('--start', type=float, help='print messages after given start time (s)')
    print_parser.add_argument('--end', type=float, help='print messages until given end time (s)')

    args = parser.parse_args()

    if args.command == 'merge':
        merge_main(args)
    elif args.command == 'print':
        print_main(args)
