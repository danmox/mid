#!/usr/bin/env python3

import argparse
import numpy as np
import re
try:
    import rosbag
    import rospy
    from or_protocol_msgs.msg import Header, Log
except:
    print('ROS environment must be sourced!')
    exit(-1)
from pathlib import Path


str_action_dict = {'RECEIVE': Log.RECEIVE, 'SEND': Log.SEND, 'RELAY': Log.RELAY, 'RETRY': Log.RETRY}
action_str_dict = {str_action_dict[key]: key for key in str_action_dict}
str_msg_type_dict = {'STATUS': Header.STATUS, 'PAYLOAD': Header.PAYLOAD, 'PING_REQ': Header.PING_REQ,
                     'PING_RES': Header.PING_RES, 'ACK': Header.ACK}
msg_type_str_dict = {str_msg_type_dict[key]: key for key in str_msg_type_dict}


def merge(args):

    if len(args.bags) < 2:
        print(f'must provide 2 or more bagfiles to merge')
        return

    bag_filenames = [Path(f) for f in args.bags]
    for name in bag_filenames:
        if not name.exists():
            print(f'bagfile {name} does not exist')
            return

    print(f"merging: {', '.join(args.bags)}")
    bags = [rosbag.Bag(f, 'r', allow_unindexed=True) for f in bag_filenames]

    messages = []
    for bag in bags:
        for topic, msg, t in bag:
            messages.append((t, topic, msg))
    messages.sort(key=lambda msg: msg[0])

    outbagfilename = args.output
    with rosbag.Bag(outbagfilename, 'w') as outbag:
        for t, topic, msg in messages:
            outbag.write(topic, msg, t)

    print(f'wrote contents to: {outbagfilename}')


def stats(args):

    bag_filename = Path(args.bag)
    if not bag_filename.exists():
        print(f'bagfile {bag_filename} does not exist')
        return

    bag = rosbag.Bag(bag_filename, 'r')
    nodes = [k for k in list(bag.get_type_and_topic_info()[1].keys()) if k[:4] == 'node']
    topic_to_index = {t: i for i, t in enumerate(nodes)}
    index_to_topic = {i: t for i, t in enumerate(nodes)}
    id_to_index = {int(re.match('^node([0-9]+)$', t).group(1)): i for i, t in enumerate(nodes)}
    index_to_id = {i: int(re.match('^node([0-9]+)$', t).group(1)) for i, t in enumerate(nodes)}
    N = len(nodes)

    pairwise_sent_msgs = np.zeros((N, N))
    pairwise_recv_msgs = np.zeros((N, N))
    pairwise_recv_bytes = np.zeros((N, N))
    total_sent_msgs = np.zeros((N,))
    total_sent_bytes = np.zeros((N,))
    total_recv_msgs = np.zeros((N,))
    total_recv_bytes = np.zeros((N,))
    total_retry_msgs = np.zeros((N,))
    total_retry_bytes = np.zeros((N,))
    total_relay_msgs = np.zeros((N,))
    total_relay_bytes = np.zeros((N,))

    for topic, msg, t in bag.read_messages(topics=nodes):
        if msg.action == Log.RECEIVE:
            sender = id_to_index[msg.header.curr_id]
            receiver = topic_to_index[topic]
            pairwise_recv_msgs[sender, receiver] += 1
            pairwise_recv_bytes[sender, receiver] += msg.size
            total_recv_msgs[receiver] += 1
            total_recv_bytes[receiver] += msg.size
        elif msg.action == Log.SEND:
            sender = id_to_index[msg.header.curr_id]
            total_sent_msgs[sender] += 1
            total_sent_bytes[sender] += msg.size
        elif msg.action == Log.RETRY:
            sender = id_to_index[msg.header.curr_id]
            total_retry_msgs[sender] += 1
            total_retry_bytes[sender] += msg.size
        elif msg.action == Log.RELAY:
            sender = id_to_index[msg.header.curr_id]
            total_relay_msgs[sender] += 1
            total_relay_bytes[sender] += msg.size

    def print_table(tab):
        spaces = 2
        col_size = [max(len(tab[i][j]) for i in range(len(tab))) for j in range(len(tab[0]))]
        for row in tab:
            padded_row = [(col_size[i] + spaces - len(row[i]))*' ' + row[i] for i in range(len(row))]
            print(''.join(padded_row))
        print('')

    # transmission statistics
    cells = [[''] + nodes]
    cells.append(['sent'] + [f'{int(n)}' if int(n) > 0 else '-'  for n in total_sent_msgs])
    cells.append(['retry'] + [f'{int(n)}' if int(n) > 0 else '-' for n in total_retry_msgs])
    cells.append(['relay'] + [f'{int(n)}' if int(n) > 0 else '-'  for n in total_relay_msgs])
    cells.append(['recv'] + [f'{int(n)}' if int(n) > 0 else '-'  for n in total_recv_msgs])

    print('totals:')
    print_table(cells)

    # SEND, RETRY delivery probability

    delivery_prob = np.zeros((N, N))
    for i in range(N):
        if total_sent_msgs[i] > 0:
            delivery_prob[i] = pairwise_recv_msgs[i] / (total_sent_msgs[i] + total_retry_msgs[i])

    cells = [[''] + nodes + ['sent']]
    for i in range(N):
        row = delivery_prob[i]
        nums = [f'{row[j]*100:.1f}' if row[j] > 1e-3 else '-' for j in range(N)]
        cells.append([nodes[i]] + nums + [f'{int(total_sent_msgs[i] + total_retry_msgs[i])}'])
    cells.append(['recv'] + [f'{int(n)}' if n > 0 else '0' for n in total_recv_msgs] + [''])

    print('delivery probability (SEND, RETRY only):')
    print_table(cells)

    # all messages delivery probability

    total_trans_msgs = total_sent_msgs + total_relay_msgs + total_retry_msgs
    all_prob = np.zeros((N, N))
    for i in range(N):
        if total_trans_msgs[i] > 0:
            all_prob[i] = pairwise_recv_msgs[i] / total_trans_msgs[i]

    cells = [[''] + nodes + ['sent']]
    for i in range(N):
        row = all_prob[i]
        nums = [f'{row[j]*100:.1f}' if row[j] > 1e-3 else '-' for j in range(N)]
        cells.append([nodes[i]] + nums + [f'{int(total_trans_msgs[i])}'])
    cells.append(['recv'] + [f'{int(n)}' if n > 0 else '0' for n in total_recv_msgs] + [''])

    print('delivery probability (all messages):')
    print_table(cells)

    # received messages

    cells = [[''] + nodes + ['sent']]
    for i in range(N):
        row = pairwise_recv_msgs[i]
        nums = [f'{int(row[j])}' if row[j] > 0 else '-' for j in range(N)]
        total_trans_msgs = int(total_sent_msgs[i] + total_retry_msgs[i] + total_relay_msgs[i])
        cells.append([nodes[i]] + nums + [f'{total_trans_msgs}'])
    cells.append(['recv'] + [f'{int(n)}' if n > 0 else '0' for n in total_recv_msgs] + [''])

    print('received messages (all messages):')
    print_table(cells)

    # flows

    flows = {}
    for topic, msg, t in bag.read_messages(topics=nodes):
        if ((msg.action == Log.SEND or msg.action == Log.RETRY) and msg.header.src_id == msg.header.curr_id) \
           or (msg.action == Log.RECEIVE and id_to_index[msg.header.dest_id] == topic_to_index[topic]):

            src = msg.header.src_id
            dest = msg.header.dest_id
            msg_type = msg.header.msg_type

            if src not in flows:
                flows[src] = {dest: {msg_type: {Log.SEND: [], Log.RECEIVE: [], Log.RETRY: []}}}
            elif dest not in flows[src]:
                flows[src][dest] = {msg_type: {Log.SEND: [], Log.RECEIVE: [], Log.RETRY: []}}
            elif msg_type not in flows[src][dest]:
                flows[src][dest][msg_type] = {Log.SEND: [], Log.RECEIVE: [], Log.RETRY: []}

            flows[src][dest][msg_type][msg.action].append(msg.header.seq)

    for src in flows:
        for dest in flows[src]:
            for msg_type in flows[src][dest]:
                sent_count  = len(set(flows[src][dest][msg_type][Log.SEND]))
                retry_count = len(set(flows[src][dest][msg_type][Log.RETRY]))
                recv_count  = len(set(flows[src][dest][msg_type][Log.RECEIVE]))
                delivery_prob = recv_count / sent_count * 100
                print(f'flow: {src} > {dest} [{msg_type_str_dict[msg_type]}]: '
                      f'{sent_count} sent, {recv_count} received, {retry_count} retried'
                      f', {delivery_prob:.1f}% delivery rate')


def msg_type_str(msg):
    if hasattr(msg, 'msg_type'):
        if msg.msg_type in msg_type_str_dict:
            return msg_type_str_dict[msg.msg_type]
    if hasattr(msg, 'action'):
        if msg.action in action_str_dict:
            return action_str_dict[msg.action]
    return 'UNKNOWN'


def print_main(args):

    bag_filename = Path(args.bag)
    if not bag_filename.exists():
        print(f'bagfile {bag_filename} does not exist')
        return

    action = None if args.action not in str_action_dict else str_action_dict[args.action]
    msg_type = None if args.type not in str_msg_type_dict else str_msg_type_dict[args.type]

    bag = rosbag.Bag(bag_filename, 'r')
    bag_start = bag.get_start_time()
    start_time = bag_start
    bag_end = bag.get_end_time()
    end_time = bag_end
    bag_duration = bag_end - bag_start
    if args.start is not None:
        if args.start > bag_duration:
            print(f'given start time ({args.start:.2f}s) after bag end ({bag_duration:.2f}s)')
            return
        start_time = args.start
    if args.end is not None:
        if args.end > bag_duration:
            print(f'given end time ({args.end:.2f}s) after bag end ({bag_duration:.2f}s)')
            return
        end_time = args.end

    time_str_len = len(f'{bag_end - bag_start:.0f}') + 9
    t0 = bag.get_start_time()
    print_count = 0
    for topic, msg, t in bag:

        if t.to_sec() < start_time:
            continue
        if t.to_sec() > end_time:
            break

        if hasattr(msg, 'action'):

            if args.node is not None and topic[:4] == 'node' and int(re.match('^node([0-9]+)$', topic).group(1)) != args.node:
                continue
            if args.seq is not None and msg.header.seq != args.seq:
                continue
            if action is not None and msg.action != action:
                continue
            if msg_type is not None and msg.header.msg_type != msg_type:
                continue
            if args.count is not None and print_count + 1 > args.count:
                break


            print_count += 1
            if args.quiet:
                continue

            time_str = ''
            if int(t.to_sec() - t0) > 0:
                time_str = f'{t.to_sec() - bag_start:.6f} s'
                t0 = t.to_sec()
            else:
                time_str = f'+{(t.to_sec() - t0)*1000:.2f} ms'
            time_str = (time_str_len - len(time_str))*' ' + time_str

            node_id = int(re.match('^node([0-9]+)$', topic).group(1))
            print(f'[{time_str}] {msg_type_str(msg)}[{node_id}]: {msg_type_str(msg.header)}:'
                  f' {msg.header.src_id} > {msg.header.dest_id} via {msg.header.curr_id}, '
                  f'{msg.size} bytes, seq={msg.header.seq}, try={msg.header.attempt}, '
                  f' rel={1 if msg.header.reliable else 0}')

    print(f'{print_count} messages')


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='operations on rosbag logs generated by or_protocol')
    subparsers = parser.add_subparsers(dest='command', required=True)

    # bag merging
    merge_parser = subparsers.add_parser('merge', help='merge multiple rosbags')
    merge_parser.add_argument('bags', type=str, nargs='+', help='bagfiles to merge')
    merge_parser.add_argument('-o', '--output', type=str, default='merged.bag', help='name of output bagfile')

    # parsing
    stats_parser = subparsers.add_parser('stats', help='compute protocol statistics')
    stats_parser.add_argument('bag', type=str, help='bagfile to parse')

    # print bag contents
    print_parser = subparsers.add_parser('print', help='print contents of bag in a human readable fashion')
    print_parser.add_argument('bag', type=str, help='bagfile to print')
    print_parser.add_argument('-t', '--type', type=str, help='only print messages of a particular type',
                              choices=['STATUS', 'PAYLOAD', 'PING_REQ', 'PING_RES', 'ACK'])
    print_parser.add_argument('-a', '--action', type=str, help='only print messages of a particular action',
                              choices=['RECEIVE', 'SEND', 'RELAY', 'RETRY'])
    print_parser.add_argument('-n', '--count', type=int, help='number of messages to print')
    print_parser.add_argument('-q', '--quiet', action='store_true', help='only print the message count')
    print_parser.add_argument('-s', '--seq', type=int, help='print messages related to a given seq number')
    print_parser.add_argument('-i', '--node', type=int, help='print messages processed at the given ID')
    print_parser.add_argument('--start', type=float, help='print messages after given start time (s)')
    print_parser.add_argument('--end', type=float, help='print messages until given end time (s)')

    args = parser.parse_args()

    if args.command == 'merge':
        merge(args)
    elif args.command == 'stats':
        stats(args)
    elif args.command == 'print':
        print_main(args)
